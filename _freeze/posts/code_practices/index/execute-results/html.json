{
  "hash": "e67ae45cf6ce4f9b9ad75dfee83ae2c1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Can your code pass the test set?\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    toc-expand: 3\nauthor: \"Felipe Angelim\"\ndate: \"2025-05-27\"\ndraft: false\ncategories: [software design, machine learning]\nthumbnail: \"imgs/darkroom.png\"\njupyter: python3\nbibliography: bibliography.bib\n---\n\n\n\nCode is not meant to be written once and never touched again. It is meant to be read, understood, and modified over time. This is especially true in dynamic environments, where requirements change, new features are added, and bugs are fixed. In such environments, code design quality is not just a nice-to-have; it is essential for the long-term success of the project.\n\nHere, I wish to share some thoughts on code design qualities, focusing on what we want, not how to get there. This is not a guide on how to write good code but rather a reflection on what good code design means in the context of software engineering and data science. This can also be useful for managers, product owners, and stakeholders who do not code but want to understand how quality impacts the product they are building.\n\nThe key takeaway I wish you to have is that **good code design is about resilience**. It is about not overfitting to our myopic view of the present, but rather about crafting a solution that can adapt and generalize to future requirements, just like a good machine learning model. It is about how effortless it is to adapt to changes.\n\n## Prelude 1: the map is not the territory\n\n![](imgs/map_territory.png){width=30% fig-align=\"center\" style=\"border-radius: 40px;\"}\n\nThere is this nice quote from Alfred Korzybski that says \"the map is not the territory\". This means that any representation of reality is not reality itself, but rather a simplification of it. Also, it is shaped by our biases and limitations.\n\nBringing it to the context of this post, we can say that **product requirements are not the product we are building**. They are a simplification of what we want to build. Naturally, details can be missing and assumptions can be wrong, because sometimes reality is more complex than what we can express in words. Sometimes, we just don't know, and that is okay. We just have to be cautious not to mistake the empty with the void.\n\nThis idea is key to understanding what comes next. Our code is designed to solve problems, but our definitions of problems are not perfect. They are made by humans, and hence this human aspect and the imprecise understanding of what should be done is deeply connected to the quality of the code we write, even more so than what our linter and unit tests end up being.\n\n## Prelude 2: easy is not simple\n\nBefore using the word \"simple\" to describe code, we should properly define what we mean by that. As gloriously explained by [Rich Hickey](https://www.youtube.com/watch?v=rI8tNMsozo0) in his talk \"Simplicity Matters,\" simple is not the same as easy. Simple is about not packing together unrelated concerns; it is about giving clear responsibility to each component, and making it easy to modify and extend. Easy, on the other hand, is subjective; it is what is closer to your knowledge and experience, it is what you are used to doing, and not necessarily good. We should focus here on the code, not on our perspective of knowledge and experience.\n\nThis definition aligns with the one in the book \"A Philosophy of Software Design\" (@ousterhout2018philosophy), which is a huge inspiration and reference for this post.\n\n> Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system\n\nComplexity is not related to the number of lines or functions; it is about the bigger picture. In his book, John Ousterhout also enumerates some symptoms of complexity:\n\n* Change amplification: when a change in one part of the system requires changes in many other parts.\n* Cognitive load: when the code is hard to understand, requiring a lot of mental effort to comprehend.\n* Unknown unknowns: when it is hard to diagnose where a change is needed to complete a task.\n\nBasically, simplicity implies less effort in the long term.\n\nThink about the code as a graph. The nodes are components (e.g., functions) we create, and the edges represent their dependencies. Simple code would be a graph with few edges, where edges represent dependencies of components on others. A dependency can be, for example, an assumption of the structure of the output of one component, the existence of certain methods, etc. The number of edges would be proportional to the complexity of the system and our cognitive load.\n\n::: {#578cd418 .cell execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){}\n:::\n:::\n\n\nIf we would perturb the graph above, such as changing the output of node 11, it would only affect the nodes that are directly connected to it, and not the whole graph. This is what we want to achieve with our code: a graph with few edges, where we can easily replace parts without affecting the whole system.\n\n::: {#a07ff44e .cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\n## The objective function\n\nHere, I'll try to define what is the objective function we should be optimizing when writing code. This is not a mathematical function, but rather a conceptual one. It is the guiding principle that should shape our design decisions and code structure.\n\n\n### Overfitting to training data\n\nOne might naively think that if a code does what it needs to do, it is good code. This though\ncan lead developers to write *easy* solutions and spaghetti code that work for the present moment but is blind to the bigger picture. \n\n\n![](imgs/illustration1.png){width=70% fig-align=\"center\" }\n\nThink about an abstract space of requirements, as in the figure above. What we see is just a small fraction of\nthe long-term objectives. Focusing too much on what we know right now makes us overfit to the training data, failing to generalize to unseen examples. **The more complex a code is, the more it is prone to overfitting**. The more hand-tuned it is to current needs, the less it can adapt to future changes. \n\n\n![](imgs/illustration2.png){width=70% fig-align=\"center\"}\n\nThe easy will possibly lead to less effort on the short term, and we will easily deliver what needs to be delivered. Over time, however, the simples, generalizable code pays back, and do not lead to an infinite increase in effort to adapt to new requirements.\n\n::: {#5f673cb8 .cell execution_count=3}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){fig-align='center'}\n:::\n:::\n\n\n### The regret\n\nI wondered a lot about what would be the true objective function we are trying to optimize when writing code and creating solutions. As machine-learning models have a metrics to define their performance, code design quality must have a way to measure how well it is designed.\n\nI came to the conclusion that the regret is a good measure of code design quality. Regret is the cumulative extra effort when compared to the best possible solution. This notion is already used in some domains of Machine Learning, particularly in Multi-armed Bandits. In Multi-armed bandits, we have access to a set of actions, and we want to choose the one that provides the highest average reward. We don't have access to full information, and we have to make decisions based on the information we have at hand. In that sense, we try to make the best sequence of actions to minimize regret over time. \nThis is similar to how we write code: we have to make decisions based on the requirements we know, and we have to adapt to changes over time. Since it is not possible to have a perfect solution from the start, we usually think about how fast we converge to the optimal solution, considering there is one. Hence, regret tells us how good we are using the current information to make decisions.\n\nThis is where experience comes in. Experienced developers can anticipate future requirements and design their code accordingly, reducing the regret. They can see beyond the current requirements and build a solution that is more resilient to change. They ask the correct questions to stakeholders, they have already seen similar changes and know what will probably come next.\n\n::: {#228c6c1b .cell execution_count=4}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){fig-align='center'}\n:::\n:::\n\n\n### Good code starts before writing code\n\n\nTaking into consideration that we have limited information, we should not try to write the perfect code from the start. The first thing we should do is **ask questions**:\n\n* What are the requirements that most likely will change in the future?\n* What are the requirements that will not change?\n* What are the assumptions we are making?\n* What is the expected lifespan of the product we are building?\n\nWith the answers to these questions, we can start thinking about the design of the code. Once we have a proposal, think about how the considered future changes would affect the design.\n\n\n![](imgs/darkroom.png){width=50% fig-align=\"center\" style=\"border-radius: 40px;\"}\n\n\nDesigning usually involves defining components and contracts between them. Defining these components involves identifies parts of the code that are stable. Hence, by asking questions, we can start to figure out what functionalitites should be clustered together.\n\n\n### Avoid premature optimization\n\nWhile we want to optimize and make our code general, guessing what will be the future requirements and diving too deep into the details is not a good idea. We call this \"premature optimization\", and can create a peak of regret, due to large effort at the start, followed by another peak of regret when the requirements change and we have to re-write our abstractions and ideas to what is truly needed.\n\n::: {#e0ccf7a2 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){fig-align='center'}\n:::\n:::\n\n\nI once found myself in a situation where I was trying to optimize a piece of code that was not even in production yet. I was radically applying SOLID principles, splitting functions into smaller and smaller pieces, trying to make it as general as possible. I was trying to anticipate future requirements that never came. The code was so abstract that it was hard to understand, and when the requirements changed, I had to rewrite everything anyway. \n\n## Takeaways\n\nT\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}