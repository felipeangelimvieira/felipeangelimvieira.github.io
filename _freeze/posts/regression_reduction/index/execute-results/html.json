{
  "hash": "966c99a571beb6ceeb3fad784b471b2f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"The most common pitfall of applying regressors to forecasting\"\nauthor: \"Felipe Angelim\"\ndate: \"2025-01-30\"\ncategories: [forecasting, timeseries]\njupyter: python3\n---\n\n\n\n\nOften, new forecasting practitioners, familiar with regression algorithms, \nuse their exact tools to forecast timeseries. Here, they belittle the consequences\nof time-dependence of the samples and the trend.\n\nThey take the timeseries, format them into a pandas dataframe, and call\nXGBoost's fit predict. \n\n\n![](thumbnail.jpg)\n\nSince this post doesn't specify an explicit `image`, the first image in the post will be used in the listing page of posts.\n\n::: {#f2e325e5 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef generate_ar1(n, phi, sigma, seed=None, freq='M', column_name='y'):\n    if seed is not None:\n        np.random.seed(seed)\n    noise = np.random.normal(0, sigma, n)\n    ar1 = np.empty(n)\n    ar1[0] = noise[0]\n    for i in range(1, n):\n        ar1[i] = phi * ar1[i - 1] + noise[i]\n    \n    # Create PeriodIndex\n    idx = pd.period_range(start='2020-01-01', periods=n, freq=freq)\n    \n    # Create DataFrame with PeriodIndex\n    df = pd.DataFrame({column_name: ar1}, index=idx)\n    \n    return df\n\ny = generate_ar1(300, 1.02, sigma=20, seed=21)\n\nfrom sktime.split import temporal_train_test_split\nfrom sktime.utils.plotting import plot_series\n\n\ny_train, y_test = temporal_train_test_split(y, test_size=0.05)\n\nplot_series(y_train, y_test, labels=[\"Train\", \"Test\"])\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){}\n:::\n:::\n\n\n::: {#4a7832e0 .cell execution_count=2}\n``` {.python .cell-code}\nfrom sktime.forecasting.ets import AutoETS\n\ny_pred_ets = AutoETS(auto=True).fit_predict(y=y_train, fh=y_test.index)\n\nplot_series(\n    y_train,\n    y_test,\n    y_pred_ets,\n    labels=[\"Train\", \"Test\", \"Exp. Smoothing\"]\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/felipeangelim/Workspace/quartoblog/.venv/lib/python3.11/site-packages/sktime/forecasting/base/adapters/_statsmodels.py:65: UserWarning: Warning: time series is not strictly positive, multiplicative components are omitted\n  self._fit_forecaster(y, X)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-2.png){}\n:::\n:::\n\n\n::: {#2f07dbf5 .cell execution_count=3}\n``` {.python .cell-code}\nfrom sktime.forecasting.compose import make_reduction\nfrom sklearn.ensemble import HistGradientBoostingRegressor\n\nrrf = make_reduction(estimator=HistGradientBoostingRegressor(), window_length=1)\n\ny_pred_tree = rrf.fit_predict(y=y_train, fh=y_test.index)\n```\n:::\n\n\n::: {#8da6d81e .cell execution_count=4}\n``` {.python .cell-code}\nplot_series(\n    y_train,\n    y_test,\n    y_pred_ets,\n    y_pred_tree,\n    labels=[\"Train\", \"Test\", \"Exp. Smoothing\", \"Tree\"]\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n::: {#abb55fc9 .cell execution_count=5}\n``` {.python .cell-code}\nplt.scatter(y_train.iloc[:-1], y_train.iloc[1:], alpha=0.3)\n\nplt.scatter(y_test.iloc[:-1], y_test.iloc[1:], alpha=0.2)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}