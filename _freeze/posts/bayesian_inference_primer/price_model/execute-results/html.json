{
  "hash": "d3869baa5b22feabbd022f1d030101a3",
  "result": {
    "engine": "jupyter",
    "markdown": "::: {#2ea6beaa .cell execution_count=1}\n``` {.python .cell-code}\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nimport numpyro.distributions as dist\nimport matplotlib.pyplot as plt\nfrom numpyro.infer import Predictive\n\nnumpyro.enable_x64()\nplt.style.use(\"seaborn-v0_8-whitegrid\")\n\n\ndef model(price, cohort, n_cohorts=4, y=None):\n\n    # Constants\n    N = len(price)\n\n    # Hyperpriors\n    sigma_slope = numpyro.sample(\"sigma_slope\", dist.HalfNormal(1000))\n    sigma_p50 = numpyro.sample(\"sigma_p50\", dist.HalfNormal(20))\n\n    with numpyro.plate(\"cohorts\", n_cohorts):\n\n        slope_i = numpyro.sample(\"mu_i\", dist.HalfNormal(sigma_slope))\n        p50_i = numpyro.sample(\"p50_i\", dist.HalfNormal(sigma_p50))\n\n    slopes = numpyro.deterministic(\"slopes\", jnp.log(1 + slope_i))\n    p50s = numpyro.deterministic(\"p50s\", p50_i)\n\n    p = 1 / (1 + (price / p50s[cohort]) ** (slopes[cohort]))\n    p = numpyro.deterministic(\"p\", p)\n    with numpyro.plate(\"observations\", N):\n        numpyro.sample(\"obs\", dist.Bernoulli(probs=p), obs=y)\n\n\nkey = jax.random.PRNGKey(0)\n\nn_cohorts = 4\nn_obs = 5000\ntrue_p50 = jnp.array([10, 12, 9, 15])\ntrue_n = jnp.array([2, 1.8, 2.5, 1.6]) * 4\n\nprice = jax.random.uniform(key, (n_obs,), minval=0, maxval=20.0)\n\ncohort_idx = jax.random.randint(key, (n_obs,), 0, n_cohorts)\np_true = 1 / (1 + (price / true_p50[cohort_idx]) ** true_n[cohort_idx])\ny = dist.Bernoulli(probs=p_true).sample(key)\n\nfrom prophetverse.engine import MCMCInferenceEngine\n\nnumpyro.enable_x64()\nnumpyro.enable_validation()\n\nengine = MCMCInferenceEngine(num_warmup=200, num_samples=200)\nengine.infer(model, price=price, cohort=cohort_idx, y=y)\n\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/400 [00:00<?, ?it/s]\rwarmup:   0%|          | 1/400 [00:00<04:58,  1.34it/s, 1 steps of size 2.34e+00. acc. prob=0.00]\rwarmup:   2%|▏         | 8/400 [00:00<00:32, 12.05it/s, 511 steps of size 3.41e-03. acc. prob=0.48]\rwarmup:   4%|▍         | 15/400 [00:00<00:17, 22.11it/s, 127 steps of size 1.16e-02. acc. prob=0.65]\rwarmup:   6%|▌         | 23/400 [00:01<00:13, 28.33it/s, 511 steps of size 4.53e-03. acc. prob=0.68]\rwarmup:   7%|▋         | 29/400 [00:01<00:10, 34.25it/s, 63 steps of size 3.11e-03. acc. prob=0.70] \rwarmup:   9%|▉         | 35/400 [00:01<00:09, 38.53it/s, 127 steps of size 1.22e-02. acc. prob=0.73]\rwarmup:  10%|█         | 42/400 [00:01<00:08, 44.22it/s, 127 steps of size 1.32e-02. acc. prob=0.74]\rwarmup:  12%|█▎        | 50/400 [00:01<00:07, 48.43it/s, 255 steps of size 7.18e-03. acc. prob=0.74]\rwarmup:  14%|█▍        | 56/400 [00:01<00:06, 51.06it/s, 63 steps of size 1.52e-02. acc. prob=0.75] \rwarmup:  16%|█▌        | 62/400 [00:01<00:06, 50.70it/s, 127 steps of size 9.92e-03. acc. prob=0.75]\rwarmup:  18%|█▊        | 71/400 [00:01<00:05, 59.88it/s, 63 steps of size 1.22e-02. acc. prob=0.75] \rwarmup:  20%|██        | 80/400 [00:02<00:04, 66.04it/s, 63 steps of size 1.57e-02. acc. prob=0.76]\rwarmup:  22%|██▏       | 87/400 [00:02<00:04, 65.27it/s, 95 steps of size 1.12e-02. acc. prob=0.76]\rwarmup:  24%|██▎       | 94/400 [00:02<00:04, 66.29it/s, 63 steps of size 1.57e-02. acc. prob=0.76]\rwarmup:  25%|██▌       | 101/400 [00:02<00:04, 63.50it/s, 255 steps of size 2.16e-01. acc. prob=0.77]\rwarmup:  37%|███▋      | 148/400 [00:02<00:01, 173.53it/s, 15 steps of size 4.83e-01. acc. prob=0.78]\rwarmup:  47%|████▋     | 189/400 [00:02<00:00, 238.58it/s, 7 steps of size 7.03e-01. acc. prob=0.78] \rsample:  61%|██████▏   | 245/400 [00:02<00:00, 329.99it/s, 7 steps of size 4.95e-01. acc. prob=0.91]\rsample:  77%|███████▋  | 308/400 [00:02<00:00, 415.10it/s, 7 steps of size 4.95e-01. acc. prob=0.91]\rsample:  92%|█████████▏| 367/400 [00:02<00:00, 464.59it/s, 7 steps of size 4.95e-01. acc. prob=0.91]\rsample: 100%|██████████| 400/400 [00:02<00:00, 134.28it/s, 7 steps of size 4.95e-01. acc. prob=0.90]\n```\n:::\n:::\n\n\n::: {#45741bf0 .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n\nfor _cohort in range(n_cohorts):\n    _price = price[cohort_idx == _cohort]\n    _p_true = p_true[cohort_idx == _cohort]\n    \n    argsort = np.argsort(_price)\n    plt.plot(\n        _price[argsort],\n        _p_true[argsort],\n        color=f\"C{_cohort}\"\n    )\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\n::: {#563eb42c .cell execution_count=3}\n``` {.python .cell-code}\nsamples = engine.predict(\n                price=price,\n                cohort=cohort_idx,\n               )\n```\n:::\n\n\n::: {#31efc1fb .cell execution_count=4}\n``` {.python .cell-code}\npercentiles = jnp.percentile(samples[\"p\"], jnp.array([25, 75]), axis=0)\naverage_p = samples[\"p\"].mean(axis=0).flatten()\nargsort = np.argsort(price)\nplt.figure()\nfor _cohort in range(n_cohorts):\n    color = f\"C{_cohort}\"\n    _price = price[cohort_idx == _cohort]\n    _average_p = average_p[cohort_idx == _cohort]\n    _percentiles = percentiles[:, cohort_idx == _cohort]\n    _true_p = p_true[cohort_idx == _cohort]\n\n    argsort = np.argsort(_price)\n\n    plt.plot(\n        _price[argsort],\n        _true_p[argsort],\n        color=color,\n        marker=\"x\",\n        linestyle=\"--\",\n        label=f\"True cohort {_cohort}\"\n    )\n    \n    plt.plot(\n        _price[argsort],\n        _average_p[argsort],\n        color=color,\n    )\n    plt.fill_between(\n        x=_price[argsort],\n        y1=_percentiles[0].flatten()[argsort],\n        y2=_percentiles[1].flatten()[argsort],\n        alpha=0.2,\n        color=color\n    )\nplt.ylim(0, 1)\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n::: {#53c2e623 .cell execution_count=5}\n``` {.python .cell-code}\n# ------------- 4.  PRIOR-predictive draws ----------------------------------\nprior_key = jax.random.PRNGKey(2025)\nprior_pred = Predictive(model, num_samples=1_000)          # no 'params' arg ⇒ prior\n\n```\n:::\n\n\n::: {#6f658839 .cell execution_count=6}\n``` {.python .cell-code}\nplt.figure()\n\nfor _cohort in range(n_cohorts):\n    prior_key, cohort_key = jax.random.split(prior_key)\n    # Generate prior samples for each cohort\n    # Note: 'y' is omitted here as we are interested in prior predictions\n    prior_samples = prior_pred(prior_key, price=price, cohort=_cohort)  # y omitted\n\n    color = f\"C{_cohort}\"\n\n    percentiles = jnp.percentile(prior_samples[\"p\"], jnp.array([25, 75]), axis=0)\n    average_prior = prior_samples[\"p\"].mean(axis=0).flatten()\n\n    argsort = np.argsort(price)\n\n    plt.plot(\n        price[argsort],\n        average_prior[argsort],\n        color=color,\n    )\n\n    plt.fill_between(\n        x=price[argsort],\n        y1=percentiles[0].flatten()[argsort],\n        y2=percentiles[1].flatten()[argsort],\n        alpha=0.2,\n        color=color,\n    )\n    plt.ylim(0, 1)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "price_model_files"
    ],
    "filters": [],
    "includes": {}
  }
}