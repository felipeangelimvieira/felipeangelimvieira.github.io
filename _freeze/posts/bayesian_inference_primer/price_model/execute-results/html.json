{
  "hash": "d3869baa5b22feabbd022f1d030101a3",
  "result": {
    "engine": "jupyter",
    "markdown": "::: {#95d05bb5 .cell execution_count=1}\n``` {.python .cell-code}\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport numpyro\nimport numpyro.distributions as dist\nimport matplotlib.pyplot as plt\nfrom numpyro.infer import Predictive\n\nnumpyro.enable_x64()\nplt.style.use(\"seaborn-v0_8-whitegrid\")\n\n\ndef model(price, cohort, n_cohorts=4, y=None):\n\n    # Constants\n    N = len(price)\n\n    # Hyperpriors\n    sigma_slope = numpyro.sample(\"sigma_slope\", dist.HalfNormal(1000))\n    sigma_p50 = numpyro.sample(\"sigma_p50\", dist.HalfNormal(20))\n\n    with numpyro.plate(\"cohorts\", n_cohorts):\n\n        slope_i = numpyro.sample(\"mu_i\", dist.HalfNormal(sigma_slope))\n        p50_i = numpyro.sample(\"p50_i\", dist.HalfNormal(sigma_p50))\n\n    slopes = numpyro.deterministic(\"slopes\", jnp.log(1 + slope_i))\n    p50s = numpyro.deterministic(\"p50s\", p50_i)\n\n    p = 1 / (1 + (price / p50s[cohort]) ** (slopes[cohort]))\n    p = numpyro.deterministic(\"p\", p)\n    with numpyro.plate(\"observations\", N):\n        numpyro.sample(\"obs\", dist.Bernoulli(probs=p), obs=y)\n\n\nkey = jax.random.PRNGKey(0)\n\nn_cohorts = 4\nn_obs = 5000\ntrue_p50 = jnp.array([10, 12, 9, 15])\ntrue_n = jnp.array([2, 1.8, 2.5, 1.6]) * 4\n\nprice = jax.random.uniform(key, (n_obs,), minval=0, maxval=20.0)\n\ncohort_idx = jax.random.randint(key, (n_obs,), 0, n_cohorts)\np_true = 1 / (1 + (price / true_p50[cohort_idx]) ** true_n[cohort_idx])\ny = dist.Bernoulli(probs=p_true).sample(key)\n\nfrom prophetverse.engine import MCMCInferenceEngine\n\nnumpyro.enable_x64()\nnumpyro.enable_validation()\n\nengine = MCMCInferenceEngine(num_warmup=200, num_samples=200)\nengine.infer(model, price=price, cohort=cohort_idx, y=y)\n\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\r  0%|          | 0/400 [00:00<?, ?it/s]\rwarmup:   0%|          | 1/400 [00:00<05:15,  1.27it/s, 1 steps of size 2.34e+00. acc. prob=0.00]\rwarmup:   2%|▏         | 8/400 [00:00<00:33, 11.60it/s, 511 steps of size 3.41e-03. acc. prob=0.48]\rwarmup:   4%|▍         | 15/400 [00:01<00:17, 21.45it/s, 127 steps of size 1.16e-02. acc. prob=0.65]\rwarmup:   6%|▌         | 23/400 [00:01<00:13, 27.76it/s, 511 steps of size 4.53e-03. acc. prob=0.68]\rwarmup:   7%|▋         | 29/400 [00:01<00:11, 33.63it/s, 63 steps of size 3.11e-03. acc. prob=0.70] \rwarmup:   9%|▉         | 35/400 [00:01<00:09, 37.97it/s, 127 steps of size 1.22e-02. acc. prob=0.73]\rwarmup:  10%|█         | 42/400 [00:01<00:08, 44.03it/s, 127 steps of size 1.32e-02. acc. prob=0.74]\rwarmup:  12%|█▎        | 50/400 [00:01<00:07, 48.97it/s, 255 steps of size 7.18e-03. acc. prob=0.74]\rwarmup:  14%|█▍        | 57/400 [00:01<00:06, 53.70it/s, 31 steps of size 1.00e-02. acc. prob=0.75] \rwarmup:  16%|█▌        | 64/400 [00:01<00:06, 52.36it/s, 15 steps of size 1.79e-02. acc. prob=0.75]\rwarmup:  18%|█▊        | 73/400 [00:02<00:05, 61.71it/s, 63 steps of size 1.29e-02. acc. prob=0.76]\rwarmup:  21%|██        | 83/400 [00:02<00:04, 67.99it/s, 127 steps of size 1.14e-02. acc. prob=0.76]\rwarmup:  23%|██▎       | 91/400 [00:02<00:04, 67.96it/s, 127 steps of size 1.20e-02. acc. prob=0.76]\rwarmup:  25%|██▍       | 99/400 [00:02<00:04, 69.74it/s, 63 steps of size 1.32e-02. acc. prob=0.76] \rwarmup:  30%|███       | 120/400 [00:02<00:02, 106.82it/s, 15 steps of size 3.42e-01. acc. prob=0.77]\rwarmup:  41%|████      | 163/400 [00:02<00:01, 195.43it/s, 7 steps of size 6.94e-01. acc. prob=0.78] \rsample:  54%|█████▍    | 217/400 [00:02<00:00, 292.33it/s, 7 steps of size 4.95e-01. acc. prob=0.91]\rsample:  70%|██████▉   | 279/400 [00:02<00:00, 385.53it/s, 7 steps of size 4.95e-01. acc. prob=0.91]\rsample:  85%|████████▌ | 341/400 [00:02<00:00, 452.88it/s, 7 steps of size 4.95e-01. acc. prob=0.90]\rsample: 100%|██████████| 400/400 [00:02<00:00, 492.82it/s, 7 steps of size 4.95e-01. acc. prob=0.90]\rsample: 100%|██████████| 400/400 [00:02<00:00, 134.59it/s, 7 steps of size 4.95e-01. acc. prob=0.90]\n```\n:::\n:::\n\n\n::: {#f7bb3bb0 .cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n\nfor _cohort in range(n_cohorts):\n    _price = price[cohort_idx == _cohort]\n    _p_true = p_true[cohort_idx == _cohort]\n    \n    argsort = np.argsort(_price)\n    plt.plot(\n        _price[argsort],\n        _p_true[argsort],\n        color=f\"C{_cohort}\"\n    )\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\n::: {#f956447b .cell execution_count=3}\n``` {.python .cell-code}\nsamples = engine.predict(\n                price=price,\n                cohort=cohort_idx,\n               )\n```\n:::\n\n\n::: {#a7ce2260 .cell execution_count=4}\n``` {.python .cell-code}\npercentiles = jnp.percentile(samples[\"p\"], jnp.array([25, 75]), axis=0)\naverage_p = samples[\"p\"].mean(axis=0).flatten()\nargsort = np.argsort(price)\nplt.figure()\nfor _cohort in range(n_cohorts):\n    color = f\"C{_cohort}\"\n    _price = price[cohort_idx == _cohort]\n    _average_p = average_p[cohort_idx == _cohort]\n    _percentiles = percentiles[:, cohort_idx == _cohort]\n    _true_p = p_true[cohort_idx == _cohort]\n\n    argsort = np.argsort(_price)\n\n    plt.plot(\n        _price[argsort],\n        _true_p[argsort],\n        color=color,\n        marker=\"x\",\n        linestyle=\"--\",\n        label=f\"True cohort {_cohort}\"\n    )\n    \n    plt.plot(\n        _price[argsort],\n        _average_p[argsort],\n        color=color,\n    )\n    plt.fill_between(\n        x=_price[argsort],\n        y1=_percentiles[0].flatten()[argsort],\n        y2=_percentiles[1].flatten()[argsort],\n        alpha=0.2,\n        color=color\n    )\nplt.ylim(0, 1)\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n::: {#7e91aca5 .cell execution_count=5}\n``` {.python .cell-code}\n# ------------- 4.  PRIOR-predictive draws ----------------------------------\nprior_key = jax.random.PRNGKey(2025)\nprior_pred = Predictive(model, num_samples=1_000)          # no 'params' arg ⇒ prior\n\n```\n:::\n\n\n::: {#78015d0d .cell execution_count=6}\n``` {.python .cell-code}\nplt.figure()\n\nfor _cohort in range(n_cohorts):\n    prior_key, cohort_key = jax.random.split(prior_key)\n    # Generate prior samples for each cohort\n    # Note: 'y' is omitted here as we are interested in prior predictions\n    prior_samples = prior_pred(prior_key, price=price, cohort=_cohort)  # y omitted\n\n    color = f\"C{_cohort}\"\n\n    percentiles = jnp.percentile(prior_samples[\"p\"], jnp.array([25, 75]), axis=0)\n    average_prior = prior_samples[\"p\"].mean(axis=0).flatten()\n\n    argsort = np.argsort(price)\n\n    plt.plot(\n        price[argsort],\n        average_prior[argsort],\n        color=color,\n    )\n\n    plt.fill_between(\n        x=price[argsort],\n        y1=percentiles[0].flatten()[argsort],\n        y2=percentiles[1].flatten()[argsort],\n        alpha=0.2,\n        color=color,\n    )\n    plt.ylim(0, 1)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](price_model_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "price_model_files"
    ],
    "filters": [],
    "includes": {}
  }
}