```{python}
import jax
import jax.numpy as jnp
import numpy as np
import numpyro
import numpyro.distributions as dist
import matplotlib.pyplot as plt
from numpyro.infer import Predictive

numpyro.enable_x64()
plt.style.use("seaborn-v0_8-whitegrid")


def model(price, cohort, n_cohorts=4, y=None):

    # Constants
    N = len(price)

    # Hyperpriors
    sigma_slope = numpyro.sample("sigma_slope", dist.HalfNormal(1000))
    sigma_p50 = numpyro.sample("sigma_p50", dist.HalfNormal(20))

    with numpyro.plate("cohorts", n_cohorts):

        slope_i = numpyro.sample("mu_i", dist.HalfNormal(sigma_slope))
        p50_i = numpyro.sample("p50_i", dist.HalfNormal(sigma_p50))

    slopes = numpyro.deterministic("slopes", jnp.log(1 + slope_i))
    p50s = numpyro.deterministic("p50s", p50_i)

    p = 1 / (1 + (price / p50s[cohort]) ** (slopes[cohort]))
    p = numpyro.deterministic("p", p)
    with numpyro.plate("observations", N):
        numpyro.sample("obs", dist.Bernoulli(probs=p), obs=y)


key = jax.random.PRNGKey(0)

n_cohorts = 4
n_obs = 5000
true_p50 = jnp.array([10, 12, 9, 15])
true_n = jnp.array([2, 1.8, 2.5, 1.6]) * 4

price = jax.random.uniform(key, (n_obs,), minval=0, maxval=20.0)

cohort_idx = jax.random.randint(key, (n_obs,), 0, n_cohorts)
p_true = 1 / (1 + (price / true_p50[cohort_idx]) ** true_n[cohort_idx])
y = dist.Bernoulli(probs=p_true).sample(key)

from prophetverse.engine import MCMCInferenceEngine

numpyro.enable_x64()
numpyro.enable_validation()

engine = MCMCInferenceEngine(num_warmup=200, num_samples=200)
engine.infer(model, price=price, cohort=cohort_idx, y=y)


```


```{python}
import matplotlib.pyplot as plt


for _cohort in range(n_cohorts):
    _price = price[cohort_idx == _cohort]
    _p_true = p_true[cohort_idx == _cohort]
    
    argsort = np.argsort(_price)
    plt.plot(
        _price[argsort],
        _p_true[argsort],
        color=f"C{_cohort}"
    )

plt.show()
```

```{python}



samples = engine.predict(
                price=price,
                cohort=cohort_idx,
               )
```


```{python}
percentiles = jnp.percentile(samples["p"], jnp.array([25, 75]), axis=0)
average_p = samples["p"].mean(axis=0).flatten()
argsort = np.argsort(price)
plt.figure()
for _cohort in range(n_cohorts):
    color = f"C{_cohort}"
    _price = price[cohort_idx == _cohort]
    _average_p = average_p[cohort_idx == _cohort]
    _percentiles = percentiles[:, cohort_idx == _cohort]
    _true_p = p_true[cohort_idx == _cohort]

    argsort = np.argsort(_price)

    plt.plot(
        _price[argsort],
        _true_p[argsort],
        color=color,
        marker="x",
        linestyle="--",
        label=f"True cohort {_cohort}"
    )
    
    plt.plot(
        _price[argsort],
        _average_p[argsort],
        color=color,
    )
    plt.fill_between(
        x=_price[argsort],
        y1=_percentiles[0].flatten()[argsort],
        y2=_percentiles[1].flatten()[argsort],
        alpha=0.2,
        color=color
    )
plt.ylim(0, 1)
plt.show()
   
```

```{python}
# ------------- 4.  PRIOR-predictive draws ----------------------------------
prior_key = jax.random.PRNGKey(2025)
prior_pred = Predictive(model, num_samples=1_000)          # no 'params' arg â‡’ prior


```

```{python}

plt.figure()

for _cohort in range(n_cohorts):
    prior_key, cohort_key = jax.random.split(prior_key)
    # Generate prior samples for each cohort
    # Note: 'y' is omitted here as we are interested in prior predictions
    prior_samples = prior_pred(prior_key, price=price, cohort=_cohort)  # y omitted

    color = f"C{_cohort}"

    percentiles = jnp.percentile(prior_samples["p"], jnp.array([25, 75]), axis=0)
    average_prior = prior_samples["p"].mean(axis=0).flatten()

    argsort = np.argsort(price)

    plt.plot(
        price[argsort],
        average_prior[argsort],
        color=color,
    )

    plt.fill_between(
        x=price[argsort],
        y1=percentiles[0].flatten()[argsort],
        y2=percentiles[1].flatten()[argsort],
        alpha=0.2,
        color=color,
    )
    plt.ylim(0, 1)
plt.show()
```